<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>全景视频查看器 (2:1)</title>
    <link rel="stylesheet" href="../css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        html, body {
            height: 100%;
        }
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        /* 覆盖全局 tool 样式，去掉容器外边距/圆角/阴影/间距，避免出现顶部“空白块” */
        .tool-container {
            height: 100vh !important;
            min-height: 100vh !important;
            width: 100% !important;
            max-width: none !important;
            margin: 0 !important;
            padding: 0 !important;
            gap: 0 !important;
            display: flex !important;
            flex-direction: column !important;
            border: none !important;
            border-radius: 0 !important;
            background: transparent !important;
            box-shadow: none !important;
        }

        .tool-header {
            margin: 0 !important;
            padding: 8px 16px !important;
            text-align: left !important;
            background: var(--bg-color, #fff) !important;
            border-bottom: 1px solid var(--border, rgba(148, 163, 184, 0.3)) !important;
            flex-shrink: 0;
        }
        /* 禁用全局 tool-header 的装饰下划线 */
        .tool-header::after {
            display: none !important;
        }
        .tool-header h1 {
            margin: 0 0 4px 0 !important;
            font-size: 16px !important;
            font-weight: 500 !important;
        }
        .tool-header p {
            margin: 0 !important;
            font-size: 12px !important;
            color: #666;
        }

        .tool-section {
            margin: 0 !important;
            padding: 8px 16px !important;
            background: var(--bg-color, #fff) !important;
            border-bottom: 1px solid var(--border, rgba(148, 163, 184, 0.3)) !important;
            flex-shrink: 0;
        }
        .tool-section label {
            display: none;
        }
        .tool-inline-controls {
            display: flex;
            gap: 8px;
        }
        .tool-inline-controls input {
            flex: 1;
            padding: 6px 12px;
            border: 1px solid var(--border-color, #e0e0e0);
            border-radius: 4px;
            font-size: 13px;
        }
        .tool-inline-controls button {
            padding: 6px 16px;
            background: var(--primary-color, #007bff);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
        }
        .tool-inline-controls button:hover {
            opacity: 0.9;
        }
        #panorama {
            flex: 1;
            width: 100%;
            background-color: #000;
            position: relative;
            min-height: 0;
        }
        .video-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        .video-controls button {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
            padding: 5px 10px;
        }
        .video-controls button:hover {
            opacity: 0.7;
        }
        .video-controls input[type="range"] {
            width: 200px;
        }
        .video-controls .time {
            color: white;
            font-size: 14px;
            min-width: 100px;
        }
    </style>
    <script src="../js/tool-theme-helper.js"></script>
</head>
<body>
    <div class="tool-container">
        <div class="tool-header">
            <h1>全景视频查看器</h1>
            <p>支持 .mp4 或 .m3u8 格式的 2:1 全景视频</p>
        </div>
        <div class="tool-section">
            <div class="tool-inline-controls">
                <input type="text" id="videoUrlInput" placeholder="输入视频 URL (.mp4 或 .m3u8)">
                <button id="loadVideoButton">加载</button>
            </div>
        </div>

        <div id="panorama">
            <p style="text-align:center; padding-top: 40px; color: #888; font-size: 14px;">输入视频 URL 并点击加载</p>
        </div>
    </div>

<script>
    const videoUrlInput = document.getElementById('videoUrlInput');
    const loadVideoButton = document.getElementById('loadVideoButton');
    const panoramaDiv = document.getElementById('panorama');

    let scene, camera, renderer, sphere, videoElement, hlsInstance;
    let isUserInteracting = false;
    let lon = 0, lat = 0;
    let onPointerDownPointerX = 0, onPointerDownPointerY = 0;
    let onPointerDownLon = 0, onPointerDownLat = 0;

    function createVideoControls() {
        const controls = document.createElement('div');
        controls.className = 'video-controls';
        controls.innerHTML = `
            <button id="playPauseBtn">▶</button>
            <span class="time"><span id="currentTime">0:00</span> / <span id="duration">0:00</span></span>
            <input type="range" id="progressBar" min="0" max="100" value="0" step="0.1">
            <input type="range" id="volumeBar" min="0" max="100" value="100" step="1" style="width: 80px;">
        `;
        return controls;
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function initThreeJS() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, panoramaDiv.clientWidth / panoramaDiv.clientHeight, 1, 1100);
        camera.target = new THREE.Vector3(0, 0, 0);

        const geometry = new THREE.SphereGeometry(500, 60, 40);
        geometry.scale(-1, 1, 1); // 反转球体使其内部可见

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(panoramaDiv.clientWidth, panoramaDiv.clientHeight);
        panoramaDiv.appendChild(renderer.domElement);

        // 事件监听
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerup', onPointerUp);
        renderer.domElement.addEventListener('wheel', onWheel);

        window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
        camera.aspect = panoramaDiv.clientWidth / panoramaDiv.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(panoramaDiv.clientWidth, panoramaDiv.clientHeight);
    }

    function onPointerDown(event) {
        isUserInteracting = true;
        onPointerDownPointerX = event.clientX;
        onPointerDownPointerY = event.clientY;
        onPointerDownLon = lon;
        onPointerDownLat = lat;
    }

    function onPointerMove(event) {
        if (isUserInteracting) {
            lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
            lat = (event.clientY - onPointerDownPointerY) * 0.1 + onPointerDownLat;
        }
    }

    function onPointerUp() {
        isUserInteracting = false;
    }

    function onWheel(event) {
        event.preventDefault();
        camera.fov += event.deltaY * 0.05;
        camera.fov = Math.max(30, Math.min(120, camera.fov));
        camera.updateProjectionMatrix();
    }

    function animate() {
        requestAnimationFrame(animate);
        update();
    }

    function update() {
        lat = Math.max(-85, Math.min(85, lat));
        const phi = THREE.MathUtils.degToRad(90 - lat);
        const theta = THREE.MathUtils.degToRad(lon);

        camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);
        camera.target.y = 500 * Math.cos(phi);
        camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);

        camera.lookAt(camera.target);
        renderer.render(scene, camera);
    }

    function initializeViewer(videoUrl) {
        // 清理旧内容
        if (renderer) {
            panoramaDiv.removeChild(renderer.domElement);
            renderer.dispose();
        }
        if (hlsInstance) {
            hlsInstance.destroy();
            hlsInstance = null;
        }
        if (videoElement) {
            videoElement.pause();
            videoElement = null;
        }
        panoramaDiv.innerHTML = '';

        // 初始化 Three.js
        initThreeJS();

        const isM3U8 = videoUrl.toLowerCase().includes('.m3u8');
        videoElement = document.createElement('video');
        videoElement.setAttribute('crossorigin', 'anonymous');
        videoElement.setAttribute('playsinline', '');
        videoElement.setAttribute('webkit-playsinline', '');
        videoElement.loop = true;
        videoElement.muted = false;

        if (isM3U8 && typeof Hls !== 'undefined' && Hls.isSupported()) {
            hlsInstance = new Hls({
                enableWorker: true,
                lowLatencyMode: false,
            });
            hlsInstance.loadSource(videoUrl);
            hlsInstance.attachMedia(videoElement);
            hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
                console.log('HLS manifest loaded');
                videoElement.play().catch(e => console.log('Autoplay prevented'));
            });
            hlsInstance.on(Hls.Events.ERROR, function (event, data) {
                console.error('HLS.js error:', data);
                if (data.fatal) {
                    switch(data.type) {
                        case Hls.ErrorTypes.NETWORK_ERROR:
                            alert('网络错误，无法加载视频');
                            break;
                        case Hls.ErrorTypes.MEDIA_ERROR:
                            hlsInstance.recoverMediaError();
                            break;
                        default:
                            alert('HLS 加载失败');
                            break;
                    }
                }
            });
        } else if (isM3U8 && videoElement.canPlayType('application/vnd.apple.mpegurl')) {
            videoElement.src = videoUrl;
        } else {
            videoElement.src = videoUrl;
        }

        videoElement.addEventListener('loadedmetadata', () => {
            const videoTexture = new THREE.VideoTexture(videoElement);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            videoTexture.colorSpace = THREE.SRGBColorSpace;

            const material = new THREE.MeshBasicMaterial({ map: videoTexture });
            const geometry = new THREE.SphereGeometry(500, 60, 40);
            geometry.scale(-1, 1, 1);

            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);

            animate();
            setupVideoControls();
        });

        videoElement.addEventListener('error', (e) => {
            console.error("Video loading error:", e);
            alert('视频加载失败，请检查 URL 是否正确或视频是否支持跨域访问');
        });

        videoElement.load();
    }

    function setupVideoControls() {
        const controls = createVideoControls();
        panoramaDiv.appendChild(controls);

        const playPauseBtn = document.getElementById('playPauseBtn');
        const currentTimeSpan = document.getElementById('currentTime');
        const durationSpan = document.getElementById('duration');
        const progressBar = document.getElementById('progressBar');
        const volumeBar = document.getElementById('volumeBar');

        // 直接设置时长，因为 loadedmetadata 已经触发过了
        if (videoElement.duration && !isNaN(videoElement.duration) && isFinite(videoElement.duration)) {
            durationSpan.textContent = formatTime(videoElement.duration);
        } else {
            // 如果还没有时长，添加监听器
            videoElement.addEventListener('durationchange', () => {
                if (videoElement.duration && !isNaN(videoElement.duration) && isFinite(videoElement.duration)) {
                    durationSpan.textContent = formatTime(videoElement.duration);
                }
            });
        }

        videoElement.addEventListener('timeupdate', () => {
            if (!videoElement.seeking) {
                const progress = (videoElement.currentTime / videoElement.duration) * 100;
                progressBar.value = progress || 0;
                currentTimeSpan.textContent = formatTime(videoElement.currentTime);
            }
        });

        playPauseBtn.addEventListener('click', () => {
            if (videoElement.paused) {
                videoElement.play();
                playPauseBtn.textContent = '⏸';
            } else {
                videoElement.pause();
                playPauseBtn.textContent = '▶';
            }
        });

        progressBar.addEventListener('input', (e) => {
            if (videoElement.duration && !isNaN(videoElement.duration)) {
                const time = (e.target.value / 100) * videoElement.duration;
                videoElement.currentTime = time;
            }
        });

        volumeBar.addEventListener('input', (e) => {
            videoElement.volume = e.target.value / 100;
        });

        videoElement.play().then(() => {
            playPauseBtn.textContent = '⏸';
        }).catch(e => {
            console.log("Autoplay prevented:", e);
            playPauseBtn.textContent = '▶';
        });
    }

    loadVideoButton.addEventListener('click', function() {
        const url = videoUrlInput.value.trim();
        if (url) {
            initializeViewer(url);
        } else {
            alert("请输入视频 URL。");
        }
    });

    videoUrlInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            loadVideoButton.click();
        }
    });
</script>

</body>
</html>
